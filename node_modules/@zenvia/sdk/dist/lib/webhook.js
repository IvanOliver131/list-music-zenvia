"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebhookController = void 0;
const express = require("express");
const types_1 = require("../types");
const logger_1 = require("../utils/logger");
const events_1 = require("events");
const http_1 = require("http");
const HTTP_CONFLICT_ERROR = 409;
class WebhookController extends events_1.EventEmitter {
    constructor(options) {
        super();
        this.app = express();
        this.options = options;
        this.logger = new logger_1.Logger(options.loggerInstance);
    }
    async init() {
        this.startServer();
        try {
            await this.startSubscriptions();
        }
        catch (error) {
            this.emit('error', error);
        }
    }
    async close() {
        this.server.close();
    }
    startServer() {
        this.app.disable('x-powered-by');
        this.app.use(express.json());
        this.app.use(this.options.path || '/', this.handler.bind(this));
        this.server = http_1.createServer(this.app);
        this.server.on('listening', () => {
            this.emit('listening');
        });
        this.server.on('error', (error) => {
            this.emit('error', error);
        });
        this.logger.debug(`Server started at port ${this.options.port}`);
        this.server.listen(this.options.port || 3000);
    }
    handler(req, res) {
        switch (req.body.type) {
            case 'MESSAGE': {
                if (this.options.messageEventHandler) {
                    const event = {
                        type: 'MESSAGE',
                        id: req.body.id,
                        timestamp: req.body.timestamp,
                        subscriptionId: req.body.subscriptionId,
                        channel: req.body.channel,
                        direction: req.body.direction,
                        message: req.body.message,
                    };
                    this.options.messageEventHandler(event);
                }
                break;
            }
            case 'MESSAGE_STATUS': {
                if (this.options.messageStatusEventHandler) {
                    const event = {
                        type: 'MESSAGE_STATUS',
                        id: req.body.id,
                        timestamp: req.body.timestamp,
                        subscriptionId: req.body.subscriptionId,
                        channel: req.body.channel,
                        messageId: req.body.messageId,
                        contentIndex: req.body.contentIndex,
                        messageStatus: req.body.messageStatus
                    };
                    this.options.messageStatusEventHandler(event);
                }
                break;
            }
            default:
            // Do nothing
        }
        res.send();
    }
    async startSubscriptions() {
        if (this.options.client && this.options.url && this.options.channel &&
            (this.options.messageEventHandler || this.options.messageStatusEventHandler)) {
            const subscriptions = [];
            if (this.options.messageEventHandler) {
                subscriptions.push(new types_1.MessageSubscription({
                    url: this.options.url,
                }, {
                    channel: this.options.channel,
                    direction: this.options.direction,
                }));
            }
            if (this.options.messageStatusEventHandler) {
                subscriptions.push(new types_1.MessageStatusSubscription({
                    url: this.options.url,
                }, {
                    channel: this.options.channel,
                }));
            }
            for (const subscription of subscriptions) {
                try {
                    await this.options.client.createSubscription(subscription);
                }
                catch (error) {
                    if (error.httpStatusCode === HTTP_CONFLICT_ERROR) {
                        this.logger.debug(`Subscription already exists. ${JSON.stringify(subscription)}`);
                    }
                    else {
                        throw error;
                    }
                }
            }
        }
    }
}
exports.WebhookController = WebhookController;
//# sourceMappingURL=webhook.js.map