"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = void 0;
const logger_1 = require("../utils/logger");
const sms_1 = require("./channels/sms");
const rcs_1 = require("./channels/rcs");
const instagram_1 = require("./channels/instagram");
const facebook_1 = require("./channels/facebook");
const whatsapp_1 = require("./channels/whatsapp");
const request = require("../utils/request");
const report_flow_1 = require("./reports/report-flow");
const report_messages_1 = require("./reports/report-messages");
const fs = require("fs");
/**
 * Client class with the features.
 */
class Client {
    /**
     * Returns a new `Client` that can be used to execute some functionality.
     *
     * @param token Zenvia platform token.
     * @param loggerInstance If you want, you can pass your log instance.
     */
    constructor(token, loggerInstance, options) {
        this.options = options;
        this.token = token;
        this.logger = new logger_1.Logger(loggerInstance);
    }
    /**
     * This method returns a channel type object.
     *
     * @param channel [[Channel]] of the instance that you want to create.
     * @returns [[Channel]] type instance.
     */
    getChannel(channel) {
        switch (channel) {
            case 'sms': return new sms_1.SmsChannel(this.token, this.logger, this.options);
            case 'rcs': return new rcs_1.RcsChannel(this.token, this.logger, this.options);
            case 'facebook': return new facebook_1.FacebookChannel(this.token, this.logger, this.options);
            case 'whatsapp': return new whatsapp_1.WhatsAppChannel(this.token, this.logger, this.options);
            case 'instagram': return new instagram_1.InstagramChannel(this.token, this.logger, this.options);
            default: throw new Error('Unsupported channel');
        }
    }
    /**
     * This method creates a message batch.
     *
     * @param contacts A [[Readable]] object.
     * @param batch Either an [[ISmsMessageBatch]] object or a [[IWhatsAppMessageBatch]] object.
     * @returns A promise that resolves an [[IMessageBatch]] object
     */
    sendMessageBatch(contacts, batch) {
        const formData = {
            batch: {
                value: JSON.stringify(batch),
                options: {
                    contentType: 'application/json',
                },
            },
            contacts: {
                value: typeof contacts === 'string' ? fs.createReadStream(contacts) : contacts,
                options: {
                    filename: typeof contacts === 'string' ? contacts : 'contacts.csv',
                    contentType: 'text/csv',
                },
            },
        };
        const path = '/v2/message-batches';
        return request.post(this.token, path, undefined, this.logger, Object.assign(Object.assign({}, this.options), { formData }));
    }
    /**
     * This method returns a list of flow reports.
     *
     * @returns [[ReportFlow]] type instance.
     */
    getFlowReportClient() {
        return new report_flow_1.ReportFlow(this.token, this.logger, this.options);
    }
    /**
     * This method returns a list of message reports.
     *
     * @returns [[ReportMessages]] type instance.
     */
    getMessagesReportClient() {
        return new report_messages_1.ReportMessages(this.token, this.logger, this.options);
    }
    /**
     * This method returns a list of subscriptions.
     *
     * @returns A promise that resolves to an array of [[ISubscription]] objects.
     */
    async listSubscriptions() {
        const path = '/v2/subscriptions';
        return request.get(this.token, path, this.logger, this.options);
    }
    /**
     * This method creates a subscription.
     *
     * @param subscription An [[ISubscription]] object.
     * @returns A promise that resolves to an [[ISubscription]] object.
     */
    async createSubscription(subscription) {
        const path = '/v2/subscriptions';
        return request.post(this.token, path, subscription, this.logger, this.options);
    }
    /**
     * This method returns a subscription.
     *
     * @param id Subscription identifier.
     * @returns A promise that resolves to an [[ISubscription]] object.
     */
    async getSubscription(id) {
        const path = `/v2/subscriptions/${id}`;
        return request.get(this.token, path, this.logger, this.options);
    }
    /**
     * This method updates a subscription.
     *
     * @param id Subscription identifier.
     * @param subscription An [[IPartialSubscription]] object.
     * @returns A promise that resolves to an [[ISubscription]] object.
     */
    async updateSubscription(id, subscription) {
        const path = `/v2/subscriptions/${id}`;
        return request.patch(this.token, path, subscription, this.logger, this.options);
    }
    /**
     * This method deletes a subscription.
     *
     * @param id Subscription identifier.
     * @returns A promise that resolves to an [[ISubscription]] object.
     */
    async deleteSubscription(id) {
        const path = `/v2/subscriptions/${id}`;
        return request.del(this.token, path, this.logger, this.options);
    }
    /**
     * This method returns a list of templates.
     *
     * @returns A promise that resolves to an array of [[ITemplate]] objects.
     */
    async listTemplates() {
        const path = '/v2/templates';
        return request.get(this.token, path, this.logger, this.options);
    }
    /**
     * This method returns a template.
     *
     * @param id Template identifier.
     * @returns A promise that resolves to an [[ITemplate]] object.
     */
    async getTemplate(id) {
        const path = `/v2/templates/${id}`;
        return request.get(this.token, path, this.logger, this.options);
    }
    /**
     * This method creates a template.
     *
     * @param template An [[ITemplate]] object.
     * @returns A promise that resolves to an [[ITemplate]] object.
     */
    async createTemplate(template) {
        const path = '/v2/templates';
        return request.post(this.token, path, template, this.logger, this.options);
    }
    /**
     * This method updates a template.
     *
     * @param id Template identifier.
     * @param template An [[IPartialTemplate]] object.
     * @returns A promise that resolves to an [[ITemplate]] object.
     */
    async updateTemplate(id, template) {
        const path = `/v2/templates/${id}`;
        return request.patch(this.token, path, template, this.logger, this.options);
    }
    /**
     * This method deletes a template.
     *
     * @param id Template identifier.
     * @returns A promise that resolves to an [[ITemplate]] object.
     */
    async deleteTemplate(id) {
        const path = `/v2/templates/${id}`;
        return request.del(this.token, path, this.logger, this.options);
    }
}
exports.Client = Client;
//# sourceMappingURL=client.js.map